Begin to Analysis....
----------------add------------
Code 1 OP_ENTRY add
Code 2 OP_DEC var is .L3
Code 3 OP_ADD .L3=x+y
Code 4 OP_DEC var is c
Code 5 OP_ASSIGN c=.L3
Code 6 OP_RETX return value is 10 and the return point is .L2
Code 7 OP_LABEL .L2
Code 8 OP_EXIT add
-------------------------------------
var size = 10
<void>, <int>, glba, s, num, x, y, .L3, c, .L5, 
fun size = 2
add, main, ----------------main------------
Code 1 OP_ENTRY main
Code 2 OP_ARG push arg 2
Code 3 OP_ARG push arg 1
Code 4 OP_CALL .L5=add
Code 5 OP_DEC var is .L5
Code 6 OP_ASSIGN glba=.L5
Code 7 OP_RETX return value is glba and the return point is .L4
Code 8 OP_LABEL .L4
Code 9 OP_EXIT main
-------------------------------------
.section .rotate
.L1:
	.ascii "Helloworld\000"
.L0:
	.ascii "%d\000"
.data
	.global glba
	.comm glba,4
	.global s
s:
	.word .L1
	.global num
	.comm num,400
.text
	.global main
main:
	# Enter the fun main
	mov ip, sp
	stmfd sp!, {fp, ip, lr, pc}
	sub fp, ip, #4
	# Allocate the stack space
	sub sp, sp, #4
	# Load the args
	# Enter the fun block
	mov r8, #2
	stmfd sp!, {r8}
	mov r8, #1
	stmfd sp!, {r8}
	bl add
	add sp, sp, #8
	str r8, [fp, #-16]
	ldr r8, [fp, #-16]
	ldr r9, =glba
	str r8, [r9, #0]
	ldr r8, =glba
	ldr r8, [r8, #0]
	b .L4
	.L4 :
	# Exit the fun main
	mov r0, r8
	ldmea fp, {fp, sp, pc}
	.global add
add:
	# Enter the fun add
	mov ip, sp
	stmfd sp!, {fp, ip, lr, pc}
	sub fp, ip, #4
	# Allocate the stack space
	sub sp, sp, #8
	# Load the args
	# Enter the fun block
	ldr r8, [fp, #4]
	ldr r9, [fp, #8]
	add r8, r8, r9
	str r8, [fp, #-16]
	ldr r8, [fp, #-16]
	str r8, [fp, #-20]
	mov r8, #10
	b .L2
	.L2 :
	# Exit the fun add
	ldmea fp, {fp, sp, pc}
